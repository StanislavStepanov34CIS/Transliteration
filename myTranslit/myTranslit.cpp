#include "stdafx.h"
#include <fstream>
#include <sstream>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <iterator>
#include <map>

#include <locale.h>
	/*!
	*\brief Функиция проверяет есть ли нелатинские символы в части с латинским представлением алфавита
	*\param[in] lat - латинская часть алфавита
	*\return - сигнал о возможности продолжить выполнение программы
	*/
bool abcLatinValidator(std::vector<std::string>& lat)
{
	std::vector<int> not_lat_pos;
	for(size_t i=0; i<lat.size(); i++)					//Для каждого прудставления...
	{
		for(size_t j=0; j<lat[i].size(); j++)				//Для каждого символа в представлении...
		{
			if(!isalpha(lat[i][j]))								//Если символ нелатинский...
			{
				not_lat_pos.push_back(i+1);						//Запомнить его позцию
				break;
			}
		}
	}
	if(!not_lat_pos.empty())																	//Если найден хотя бы 1 нелатинский символ...
	{		
		std::cerr << "Не латинское представление в словаре на позиции: ";							//Вывести сообщение об ошибке
		for(std::vector<int>::iterator it = not_lat_pos.begin(); it!=not_lat_pos.end(); ++it)
		{
			std::cerr << *it << " ";
		}
		std::cerr << std::endl;
		return false;																				//Сигнал о прекращении программы
	}
	else																						//Иначе...
	{
		return true;																				//Сигнал продолжении выполнения программы
	}

}

	/*!
	*\brief Функиция проверяет максимальный размер представления в словаре
	*\param[in] lat - латинская часть алфавита
	*\return - сигнал о возможности продолжить выполнение программы
	*/
bool abcSizesValidator(std::vector<std::string>& lat)
{
	for(size_t i=0; i<lat.size(); i++)				//Для каждого представления...
	{
		if(lat[i].size()>3)								//Если длина представления больше 3...
		{
			std::cerr <<"Есть латинские представления кириллицы с длиной больше 3 символов на позиции: " << i+1 << std::endl;	//Вывести сообщение об ошибке
			return false;									//Сигнал о прекращении выполнения программы
		}
	}
	return true;											//Сигнал о продолжении выполнения программы
}

	/*!
	*\brief Функиция проверяет повторения представлений в словаре
	*\param[in] lat - кириллическая часть алфавита
	*\param[in] tus - латинская часть алфавита
	*\return - сигнал о возможности продолжить выполнение программы
	*/
bool abcOverlapValidator(std::vector<std::string>& lat,std::vector<std::string>& rus)
{
	for(size_t i=0; i<lat.size()-1; i++)			//Для кажого представления...
	{
		for(size_t j=i+1; j<lat.size(); j++)			//Для кажого следующего представления...
		{
			if(lat[i]==lat[j])								//Если представления совпадают...
			{
				std::cerr<< "!В словаре есть одинаковые латинские представления букв!" <<std::endl;	//Сообщить об ошибке
				return false;			//Сигнал о прекращении выполнения программы
			}
		}
	}
	for(size_t i=0; i<rus.size()-1; i++)			//Для кажого представления...		
	{
		for(size_t j=i+1; j<rus.size(); j++)			//Для кажого следующего представления...
		{
			if(rus[i]==rus[j])								//Если представления совпадают...
			{	
				std::cerr<< "!В словаре есть одинаковые кириллические представления букв!" <<std::endl;	//Сообщить об ошибке
				return false;			//Сигнал о прекращении выполнения программы
			}
		}
	}
	return true;					//Сигнал о продолжении выполнения программы
}

	/*!
	*\brief Функиция проверяет кол-во кириллических и латинских представлений символов
	*\param[in] rus - кириллическая часть алфавита
	*\param[in] lat - латинская часть алфавита
	*\return - сигнал о возможности продолжить выполнение программы
	*/
bool abcCountFileValidator(std::string& rus, std::string& lat)
{
	int lat_count_val = 0;					//Кол-во латинских представлений
	int rus_count_val = 0;					//Кол-во кириллических представлений
	for(size_t i = 0; i < lat.size(); i++)	//Для каждого символа в стороке...
	{
		if(lat[i]==';' && lat[i]!=lat[i+1])							//Если найден символ разделитель...
			lat_count_val++;					//Увеличить кол-во представлений на 1
	}

	for(size_t i = 0; i < rus.size(); i++)	//Для каждого символа в стороке...
	{
		if(rus[i]==';' && rus[i]!=rus[i+1])							//Если найден символ разделитель...
			rus_count_val++;					//Увеличить кол-во представлений на 1
	}

	if(rus_count_val!=lat_count_val)
	{
		std::cerr << "!Не совпадает кол-во кириллических и латинских представлений в словаре!\nКириллических: " << rus_count_val+1 << "\nЛатинских: "<< lat_count_val+1 << std::endl;
		return false;					//Сигнал о прекращении выполнения программы
	}
	else
	{
		return true;					//Сигнал о продолжении выполнения программы
	}

}

	/*!
	*\bbrief Функиция проверяет, можно ли транслитировать текущую последовательность символов, не заводя транслитерацию в тупик
	*\param[in] src - транлитируемый текст
	*\param[in] abc - словарь правил транслитерации
	*\param[in] translitPos - позиция транслитерации
	*\return - сигнал о возможности транслитировать текущую комбинацию символов
	*/
int canTranslit(const std::string& src, const std::map<std::string,std::string>& abc, int translitPos)
{
	std::string src_buf;						//Буферная строка, содержит рассматриваемую комбинацию символов
	
	for(int i = translitPos; i<src.size(); i++)	//Для каждого символа...
	{

		src_buf.push_back(src[i]);																							//Добавить символ в буферную строку
		if(src.size()-translitPos==1 && abc.find(src_buf)!=abc.end())														//Если конец строки и комбинация символов есть в словаре...
		{
			src_buf.clear();																									//Очистить буферную строку
			return 1;																											//Сигнал о возможности транслитировать комбинацю символов длиной 1
		}
		else if(src.size()-translitPos>=1 && abc.find(src_buf)!=abc.end() && canTranslit(src,abc,i+1))						//Иначе Если до конца строки еще 1 символ(или более) и комбинация символов есть в словаре и дальнейшая транслитерация не зайдетв тупик
		{
			src_buf.clear();																									//Очистить буферную строку
			return 1;																											//Сигнал о возможности транслитировать комбинацю символов длиной 1
		}
		else if(src.size()-translitPos>=2 && abc.find(src_buf+ src[i+1])!=abc.end() && canTranslit(src,abc,i+2))			//Иначе Если до конца строки еще 2 символа(или более) и комбинация символов есть в словаре и дальнейшая транслитерация не зайдетв тупик
		{
			src_buf.clear();																									//Очистить буферную строку
			return 2;																											//Сигнал о возможности транслитировать комбинацю символов длиной 2
		}
		else if(src.size()-translitPos>=3 && abc.find(src_buf+ src[i+1] + src[i+2])!=abc.end() && canTranslit(src,abc,i+3))	//Иначе Если до конца строки еще 3 символа(или более) и комбинация символов есть в словаре и дальнейшая транслитерация не зайдетв тупик
		{
			src_buf.clear();																									//Очистить буферную строку
			return 3;																											//Сигнал о возможности транслитировать комбинацю символов длиной 3
		}
		else if(!isalpha(src[translitPos]))																					//Иначе Если рассматриваемый символ нелатинский...
		{
			src_buf.clear();																									//Очистить буферную строку
			return 4;																											//Сигнал о том что в комбинации есть нелатинский символ, ненарушающий транслитерацию
		}
		else																												//Иначе...
		{
			src_buf.clear();																									//Очистить буферную строку
			return 0;																											//Сигнал о невозможности транслитировать комбинацю символов
		}
	}
}

	/*!
	*\brief Функция транслитерации
	*\param [in] src - транслитируемый текст
	*\param [in] abc - словарь, где ключи это русский алфавит на кириллице, а содержимое - русский алфавит на латинице. 
	*\return - транслитированный текст на кириллице
	*/
std::string Translit(const std::string& src, const std::map<std::string,std::string> abc)
{
	std::string res;														//Строка для записи готового текста
	std::string src_buf;													//Буфер для хранения символов транслитируемого текста
	int can_translit = 0;													//Длина возможной транслитерации, которя не заведет в тупик дальнейшую транслитерацию
	for(int i=0; i<src.size(); i++)											//Для каждого символа...
	{
		if(isalpha(src[i]))														//Если символ латинский...
		{
			can_translit = canTranslit(src,abc,i);									//Проверить, можно ли его транслитировать
			if(can_translit==1)														//Если можно транслитировать..
			{
				src_buf.push_back(src[i]);												//Записать в буферную строку этот символ
				res.append(abc.find(src_buf)->second);									//Записать кириллический вариант в результирующую строку
			}
			else if(can_translit==2)												//Иначе Если можно транслитировать его и соседа справа...
			{
				src_buf.push_back(src[i]);
				src_buf.push_back(src[i+1]);											//Записать в буферную строку этот символ и его соседа справа
				res.append(abc.find(src_buf)->second);									//Записать кириллический вариант в результирующую строку
				i++;;																	//Учесть символ из транслитированной комбинации
			}
			else if(can_translit==3)												//Иначе Если Если можно транслитировать его и 2-х соседей справа...
			{
				src_buf.push_back(src[i]);
				src_buf.push_back(src[i+1]);
				src_buf.push_back(src[i+2]);											//Записать в буферную строку этот символ и его 2 соседей справа
				res.append(abc.find(src_buf)->second);									//Записать кириллический вариант в результирующую строку
				i+=2;																	//Учесть символы из транслитированной комбинации
			}
			else																	//Иначе...
			{
				while(isalpha(src[i]))
				{
					res.append("~");														//Записать в результирующую строку символ пропуска
					i++;
				}
				i--;
			}
		}
		else																	//Иначе...
		{
			res.push_back(src[i]);													//Не транслитировать символ
		}
		src_buf.clear();														//Очистить буферную строку
	}
	return res;																//Вернуть значение результирующей строки

	
}


/*! \mainpage myTranslit
*
* Данная программа используется
*	для обратной транслитерации текста
*	на основе заданных правил транслитерации
*	записанных в файле-словаре
* \authors Степанов Станислав Владиславович
*/
int main(int argc, char **argv)
{
	::setlocale(LC_ALL, "Russian");											//Задать локаль
	if (argc != 4)															//Если кол-во аргументов не равно 4...
	{
		std::cerr << "Неверно заданы параметры" << std::endl;						//Вывести сообщение об ошибке
		std::cerr << "Формат myTranslit.exe infile.txt outfile.txt abc.txt" << std::endl;
		system("pause");
		return 1;																	//Завершить программу
	}
	std::fstream In(argv[1], std::ios_base::in);								//Открыть файл с транслитируемым текстом
	if (!In.is_open())														//Если не удалось открыть...
	{
		std::cerr << "Не удалось открыть входной файл" << std::endl;				//Выести сообщение об ошибке
		system("pause");
		return 1;																	//Завершить программу
	}
	std::fstream Out(argv[2], std::ios_base::out);							//Открыть файл для записи текста на кириллице
	if (!Out.is_open())														//Если не удалось открыть...
	{
		std::cerr << "Не удалось открыть выходной файл" << std::endl;				//Вывести сообщение об ошибке
		system("pause");
		return 1;																	//Завершить программу
	}
	std::fstream Dict(argv[3], std::ios_base::in);							//Открыть файл со словарем
	if (!Dict.is_open())														//Если не удалось открыть...
	{
		std::cerr << "Не удалось открыть файл со словарем" << std::endl;			//Вывести сообщение об ошибке
		system("pause");
		return 1;																	//Завершить программу
	}

  //-------------------------

	std::string Res;
	std::vector<char> Buf;										//Буффер
	for (std::vector<char> Tmp(1024) ; !In.eof() ; )				//Пока файл не кончился
	{
		std::fill(Tmp.begin(), Tmp.end(), 0);							//Заполнить переменную среды нулями
		In.read(&Tmp[0], static_cast<std::streamsize>(Tmp.size()));		//Считать транслитируемый файл
		std::vector<char>::iterator End = std::find_if(
			Tmp.begin(), Tmp.end(),
			std::bind2nd(std::equal_to<char>(), 0)						//Установать итератор для переменной среды
			);
		if (End == Tmp.begin())											//Если итератор установился на начало переменной среды...
			break;															//Выйти из цикла
		std::copy(Tmp.begin(), End, std::back_inserter(Buf));			//Скопировать значения перемнной среды в буффер
	 }
		if (!Buf.empty() && Buf.back() != 0)							//Если буффер не пустой и псоледний элемент буффера не равен 0
			Buf.push_back(0);												//Добавить в конец нуль

//-------------------------

	std::vector<std::string> rus;								//Массив для хранения кириллической части словаря (будут использованы как значения)
	std::vector<std::string> lat;								//Массив для хранения латинской части словаря (будут использованы как ключи)
	int lat_count_val = 0;
	int rus_count_val = 0;
	std::string buff[2];										//Массив строк для считывания словаря
	std::string tmp;											//Буффер
	int i = 0;													
	while(!Dict.eof() && i < 2)									//Пока файл не закончился...
	{
		getline(Dict,buff[i++]);									//Получить значение строки словаря
	}

//-----------------------------

	if(!abcCountFileValidator(buff[0],buff[1]))						//Проверить словарь на кол-во латинских и кириллических представлений букв
	{
		system("pause");
		return 1;														//Завершить программу
	}

//-----------------------------

	std::istringstream rus_stream(buff[0]);						//Передать строки словаря в поток
	std::istringstream lat_stream(buff[1]);
	while(std::getline(rus_stream,tmp,';'))						//Разбить строку на значения словаря
		rus.push_back(tmp);											//Поместить кириллический алфавит в массив
	tmp.clear();												//Очистить буффер
	while(std::getline(lat_stream,tmp,';'))						//Разбить строку на ключи словаря
		lat.push_back(tmp);											//Поместить латинский алфавит в массив
	tmp.clear();												//Очистить буффер
	
//-----------------------------

	if(!lat.empty() && !rus.empty() && !abcOverlapValidator(lat,rus))	//Проверить наличие повторяющихся представлений
	{
		system("pause");
		return 1;															//Завершить программу
	}

//-----------------------------

	if(!abcLatinValidator(lat))											//Проверить наличие нелатиснких символов в латинской части
	{
		system("pause");
		return 1;															//Завршить программу
	}

//-----------------------------

	if(!abcSizesValidator(lat))											//Проверить максимальный размер латинского представления
	{
		system("pause");
		return 1;															//Завершить программу
	}

//-----------------------------

	std::map<std::string,std::string> alphabet;					//Создать словарь
	for(size_t i = 0; i < lat.size(); i++)
	{
		alphabet[lat[i]]=rus[i];								//Заполнить ключами и значениями
	}

	if(!Buf.empty())
	{
		Res = Translit(&Buf.front(), alphabet);			//Транслитировать текст, находящийся в файле
	}
	else
	{
		Res = "";
	}
	Out.write(Res.c_str(), static_cast<std::streamsize>(Res.length())); //Записать кириллический текст в файл

//-----------------------------

	In.close();													//Закрыть потоки
	Out.close();
	Dict.close();
	std::cout << "Текст успешно транслитирован, результат можно посмотреть в файле outfile.txt" << std::endl;
	system("pause");
	return 0;
}
